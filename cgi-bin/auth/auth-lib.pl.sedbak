#!/usr/bin/perl -T
# auth-lib - library used for user authentication for a web based system
package auth;

# The auth-lib and all related scripts are part of WebKNotes
# The WebKNotes system is Copyright 1996-1999 Don Mahurin.
# For information regarding the copying/modification policy read 'LICENSE'.
# dmahurin@users.sourceforge.net

sub get_user()
{
   my($chip,$value);
   foreach (split(/; /, $ENV{'HTTP_COOKIE'}))
   {
      ($chip,$value) = split(/=/);
      $cookie{$chip} = $value;
   }
   return () unless(defined($cookie{'sessionid'}));
   my($user, $vword) =  split(/:/,$cookie{sessionid});
   $user =~ m:^([^/]*)$: ; $user = $1; # untaint
   my($sess_file) = "$auth::session_dir/$user";
   unless( -f $sess_file )
   {
      print "No session file: $sess_file\n";
      return ();
   }
   open(SFILE, $sess_file);
   $line = <SFILE>;
   close(SFILE);
   my($vcrypt,$addr) = split(/:/, $line);
   if($ENV{'REMOTE_ADDR'} ne $addr or pcrypt1($vword) ne $vcrypt )
   {
      print "mismatch of remote address and session address\n";
      return ();
   }
   return $user;
}

sub get_path_group
{
   my($path) = @_;
   if( -f "$auth::doc_dir/$path/.group" and
     open(GFILE, "$auth::doc_dir/$path/.group" ) )
   {
     my($group) = <GFILE>;
     chomp($group);
     close(GFILE);
     return $group;
   }
   return ();
}

sub get_path_permissions
{
   my($path) = @_;
   if( -f "$auth::doc_dir/$path/.permissions" and
      open(PFILE, "$auth::doc_dir/$path/.permissions" ) )
   {
      my($permissions) = <PFILE>;
      chomp($permissions);
      close(PFILE);
      return $permissions;
   }
   return "";
}

sub set_path_group
{
   my($path, $group) = @_;
   if ( open(GFILE, ">$auth::doc_dir/$path/.group" ) )
   {
      print GFILE "$group";
      close(GFILE);
      return 0;
   }
   return 1;
}

sub set_path_permissions
{
   my($path, $permissions) = @_;
   if ( open(PFILE, ">$auth::doc_dir/$path/.permissions" ) )
   {
      print PFILE "$permissions";
      close(PFILE);
      return 0;
   }
   return 1;
}

sub change_permissions
{
   my($permissions, @new_permissions) = @_;
#   print "change: $permissions:@new_permissions\n";

   my($subtract);
   my($p);
   $permissions = "" unless(@new_permissions);
   foreach $p (@new_permissions)
   {
      if($p eq '=') { $permissions = ""; }
      elsif($p eq '+') { $subtract = 0; }
      elsif($p eq '-') { $subtract = 1; }
      else
      {
          $permissions = "" unless(defined($subtract));
          $permissions =~ s:$p::g;
          $permissions .= $p unless($subtract);
      }
   }
#   print "newperm: $permissions\n";
   return $permissions;
}

sub check_file_auth
{
  my($user, $file, $flag) = @_;
  my($auth_pass, $auth_path, $auth_flags, @other);

  if ( -d "$auth::doc_dir/$file")
  {
     $file_dir = $file;
  }
  else
  {
     $file_dir = $file;
     $file_dir =~ s:/[^/]*$::;
     $file_dir =~ s:^([^/]|$):/$1:;
  }
  my(@path_permissions);
  @path_permissions = split(//, get_path_permissions($file_dir)) or 
    undef(@path_permissions);

  if( defined($user) and open(UFILE, "$auth::users_dir/$user") )
  {
     ($auth_pass, $auth_path, $auth_flags, @other) = split(/:/, <UFILE>);
#print "user auth: $auth_flags\n";
     close(UFILE);
     $auth_flags =
        change_permissions($auth_flags, @path_permissions )
           if(defined(@path_permissions));

     if( $auth_flags =~ m:o: and -f "$auth::doc_dir/$file_dir/.owner" and
        open(OFILE, "$auth::doc_dir/$file_dir/.owner" ) )
     {
        my($owner) = <OFILE>;
        chomp($owner);
        close(OFILE);
        if( $user eq $owner) 
        {
          $auth_flags = change_permissions($auth_flags,
             '+', split(//, $auth::owner_flags) );
        }
     } 
     my($group);
     if( defined($group = get_path_group($file_dir)))
     {
        if(open(GFILE, "$auth::groups_dir/$group"))
        {
           my($members, $permissions, @other) = split(/:/, <GFILE>);
           close(GFILE);
           if( $members =~ m:(^|,)$user(,|$): )
           {
              $auth_flags = change_permissions($auth_flags,
                 '+', split(//, $permissions) );
           }
        }
     }
  }
  if( ! defined($auth_flags) )
  {
     $auth_flags = $auth::default_flags;
     $auth_path = $auth::default_path;
     $auth_flags = change_permissions($auth_flags, @path_permissions)
        if(defined(@path_permissions));
  }
  
#print "$auth_flags:$flag:$file_dir:$auth_path\n";
  if( defined($auth_path) and ! "/$file_dir/" =~ m:^/*$auth_path/+: )
  {
     return 0;
  }
  if( $auth_flags =~ m:$flag: )
  {
     return 1;
  }
  else
  {
     return 0;
  }
}

sub user_exists
{
   my($username) = @_;

   return( -f "$auth::users_dir/$username");
}

sub modify_user_info
{
   my($username, $password, $path, $flags, $fullname, $email, @otherinfo) = @_;

   if($username =~ m:^([^/]+)$:)
   {
      $username = $1;
   }
   else
   {
      print "illegal user value\n";
      return 0;
   }
  
   if($password)
   {
      $password = pcrypt1($password);
   }
   else
   {
      my($old_password, @oldstuff) =
         &get_user_info($username);
      $password = $old_password if ( defined($old_password) );
   }

   return 0 unless open( UFILE, ">$auth::users_dir/$username");
   print UFILE join(':', $password, $path, $flags, $fullname, $email, @otherinfo);
   close(UFILE);
   return 1;
}

sub check_pass
{
   my($user, $pass) = @_;

   open(UFILE, "$auth::users_dir/$user");
   my($auth_pass, $auth_path, $auth_flags, @other) = split(/:/, <UFILE>);
   close(UFILE);

   return ( $auth_pass eq "" or pcrypt1($pass) eq $auth_pass);
} 

sub get_user_info
{
   my($user) = @_;

   if( ! -f "$auth::users_dir/$user" )
   {
      print "user file not found:$auth::users_dir/$user\n";
      return ();
   }
   open(UFILE, "$auth::users_dir/$user");
   @info = split(/:/, <UFILE>);
   close(UFILE);
   return @info;
}

sub pcrypt1
{
        my($word) = @_;
        return crypt($word,"MM");
}

sub pcrypt2
{
        my($word) = @_;
        return substr(crypt($word, "DO"), 2,8);
}

sub create_session
{
   my($user) = @_;

   $vword = create_vword();
   $vcrypt = pcrypt1($vword);
   $sessionid = "$user:$vword";
   $addr = $ENV{'REMOTE_ADDR'};
   $user =~ m:^([^/]+)$:;
   my($sfile) = "$auth::session_dir/$1";

   return 0 unless(open(SFILE, ">$sfile")); 
   print SFILE "$vcrypt:$addr"; 
   close(SFILE);
   print "Set-Cookie: sessionid=$sessionid; path=/\n";
   return 1;
}

sub create_vword
{
   my($i, $word);
   $word = "";

   for($i = 0; $i < 8; $i++)
   {
      $num = rand(62);
      if( $num < 10)
      {
         $add = 48;
      }
      elsif ( $num < 36 )
      {
         $add = 55;
      }
      else
      {
         $add = 61;
      }

      $word .= pack("C", $num +$add);
   }

   return $word;
}
1;
