#!/usr/bin/perl

#use strict;

my $install = 1;
my $wkn_cgi_dir;

for my $arg (@ARGV)
{
   if($arg =~ m:^--cgi=:)
   {
      $wkn_cgi_dir = $';
      shift(@ARGV);
   }
   elsif($arg eq "--setup-only")
   {
      $install = 0;
   }
}

# need local for var_eval
local($HOME); # = $ENV{HOME};

my(%symbols);


my($user);

if($<)
{
   $user = getpwuid($<)
}

my($package) = "main";

# need local for var_eval
local ($web_doc_root, $cgi_root, $cgi_root_wpath,
   $user_dir);

unless(defined($wkn_cgi_dir) and -f "$wkn_cgi_dir/filedb_define.pl" and
-f "$wkn_cgi_dir/view_define.pl")
{

($web_doc_root, $cgi_root, $cgi_root_wpath,
   $user, $user_dir) =

   &chomp_slashs(parse_httpd());

if((!defined($user)) or $user eq "nobody")
{
   $user = "www";
}
my(@userinfo) = getpwnam($user);
$HOME = $userinfo[7];
$HOME="/home/httpd" unless(defined($HOME) and $HOME ne "/" and $HOME ne "");

my $default = ( $< && $user ne "www") ? "u" : "r";

if(prompt_default("Install in web Root or User directory", $default, "(r|u)") eq "r")
{
   $web_doc_root = "/home/httpd/html"
      unless(defined($web_doc_root));
   my $web_doc_root_wpath = "";
}
else
{
   if(defined($user_dir))
   {
      $web_doc_root = "$ENV{\"HOME\"}/$user_dir";
   }
   else
   {
      $web_doc_root = "$ENV{\"HOME\"}/public_html";
   }
   undef $cgi_root;
   undef $cgi_root_wpath;
   $web_doc_root_wpath = "/~$ENV{\"USER\"}";
}

$web_doc_root = prompt_default("Web document root", $web_doc_root);
$web_doc_root_wpath = prompt_default("Web document root web path", $web_doc_root_wpath);


unless($cgi_root)
{
   $cgi_root = "$web_doc_root/cgi-bin";
   $cgi_root_wpath = "$web_doc_root_wpath/cgi-bin";
}

   $wkn_cgi_dir = prompt_default("cgi-bin install directory", "$cgi_root/wkn");

}

exit unless(open(IN, "define.in"));
while(defined(my $line = <IN>))
{
  if($line =~ m:(\S+)\s+(\S+)(\s+\"([^\"]*)\")?(\s+\"([^\"]*)\")?:)
  {
     my ($type, $var, $prompt, $default) = ($1, $2, $4, $6);
     my ($hashvar);
     if($type eq "PACKAGE") {
         $package = $var;
         if( -f "$wkn_cgi_dir/${package}_define.pl" ) { 
            require "$wkn_cgi_dir/${package}_define.pl";
            if($package eq "view") { # compatibility with old defines
               $view::define::file_icons->{"closed"} =
                $view::define::closed_icon
                if(defined($view::define::closed_icon));
               $view::define::file_icons->{"opened"} =
                $view::define::opened_icon
                if(defined($view::define::opened_icon));
               $view::define::file_icons->{"dir"} =
                $view::define::dir_icon
                if(defined($view::define::dir_icon));
               $view::define::file_icons->{"file"} =
                $view::define::file_icon
                if(defined($view::define::file_icon));
             }
         }
         next; 
     }
     next if($type eq "SUB"); # can't retrieve a sub from define file
     if($var =~ m:\{([^\}]+)\}$:)
     {
        $var = $`;
	$hashvar = $1;
     }
           
     my($varref);
     if(defined($hashvar))
     {
         $varref = \${"${package}::define::$var"}->{$hashvar};
     }
     else
     {
        $varref = \${"${package}::define::$var"};
     }
     $default = $$varref if(defined($$varref));
    
     # skip if no default or previous user value (hash's have no default)
     next if( $type ne "HASH" && !defined($default));

     push(@{$symbols{$package}}, $var) if( ! defined($hashvar) and $package ne "main");
     next if($type eq "HASH"); # manually configured
     
     $default =~ s:\$\{([^\}]+)\}:&eval_var($1):ge;
     $$varref = type_prompt($type, $prompt,  $default);
  }
}
close(IN);

#INSTALLATION follows

if(prompt_default("Copy webknotes cgi-bin", $install ? "y" : "n", "(y|n)") eq "y")
{
   mkpath($wkn_cgi_dir, 0755);
   system("cp -r cgi-bin/* $wkn_cgi_dir");

   print "Note: WebKNotes requires some sort of setuid mechanism. You have these coices:\n";
   print "\tApache setuid_mod - if enabled, you do nothing\n";
   print "\tcgiwrap - Your cgi web path will be: /cgi-bin/cgiwrap/webuser/wkn\n";
   print "\tsperl - A c program that provides a secure setuid mechanism for one specific user\n";
   print "\tchmod +s on *.cgi\n";
   print "\tChange User/Group in httpd.conf to owner of files (Not recommended if untrusted users)\n";
      
   print "\n";
   my $sid_mod = prompt_default("What setuid mechanism should be used?", 
      "other", "(chmod|sperl|other)");
   if($sid_mod eq "chmod")
   {
      system("chmod a+x,u+s $wkn_cgi_dir/*.cgi");
   }
   elsif($sid_mod eq "sperl")
   {
      my $perl = `which perl`; chomp $perl;
      my $perldef = $perl eq '/usr/bin/perl'? "" : "-DCOMMAND=$perl";
      system("cc $perldef util/sperl_user.c -o $wkn_cgi_dir/sperl_$user");
      my $rtn = $? << 8;
      if($rtn) { print "There was a problem compiling sperl_user.c\n";}
      else
      {
         system("chmod a+x,u+s $wkn_cgi_dir/sperl_$user");
         system("util/perlpath $wkn_cgi_dir/sperl_$user $wkn_cgi_dir/*.cgi\n");
         system("chmod a+x $wkn_cgi_dir/*.cgi");
      }
   }
}

if('y' eq prompt_default("Write configuration in $wkn_cgi_dir?", "y", "(y|n)"))
{


for my $pack (keys %symbols)
{
   open(DFILE, ">$wkn_cgi_dir/${pack}_define.pl");
   print DFILE "package ${pack}::define;\n\n";
   
   for my $var (@{$symbols{$pack}})
   {
      if(ref ${"${pack}::define::$var"} eq "HASH")
      {
         print DFILE "\$$var = \n{\n";
         for my $key (keys %${"${pack}::define::$var"})
         {
            print DFILE  "'$key'=>'" . ${"${pack}::define::$var"}->{$key} . "',\n";
         }
         print DFILE "};\n";
   
      }
      else
      {
      my $val = ${"${pack}::define::$var"};
      print DFILE "\$$var = '$val';\n";
      }
   }
   print DFILE "\n1;\n";
   close(DFILE);
}
}

unless(defined($filedb::define::doc_dir))
{
	print "Error doc dir is not defined\n";
	exit(1);
}

$default = ( -d $filedb::define::doc_dir) ? "n" : "y";
print "Error creating directory: $filedb::define::doc_dir\n" unless( -d $filedb::define::doc_dir or mkpath($filedb::define::doc_dir,0755));
if(prompt_default("Copy sample notes", $default, "(y|n)") eq "y")
{
   mkdir("$filedb::define::doc_dir/webknotes", 0755);
   system("cp 'doc'/* $filedb::define::doc_dir/webknotes");
}

if(prompt_default("Copy sample icons", ( $install )? "y" : "n",
   "(y|n)") eq "y")
{
   mkpath($view::define::icons_dir,0755);
   system("cp -r 'icons'/* $view::define::icons_dir");
}

if(prompt_default("Copy sample themes", ( $install )? "y" : "n",
   "(y|n)") eq "y")
{
   mkpath($view::define::themes_dir,0755);
   system("cp -r 'themes'/* $view::define::themes_dir");
}

# upgrade to 1.0
if(defined($auth::define::private_dir && !defined ($filedb::define::private_dir)))
{
   $filedb::define::private_dir = $auth::define::private_dir;
   undef $auth::define::private_dir;
}

if(prompt_default("Create private web dir",
(-d $filedb::define::private_dir ) ? "n" : "y", "(y|n)") eq "y")
{
   mkpath($filedb::define::private_dir,0700);
   unless(
      mkdir("$filedb::define::private_dir/groups",0700) &&
      mkdir("$filedb::define::private_dir/users",0700) &&
      mkdir("$filedb::define::private_dir/sessions",0700))
   {
      print "Error making directory: $filedb::define::private_dir\n";
   }
}

   my $admin_user = "admin";
   $default = ( -f "$filedb::define::private_dir/users/$admin_user" ) ? "n" : "y";
   if( prompt_default("Create Admin login as '$admin_user'", $default, "(y|n)") eq "y")
   {
      my($admin_password, $admin_password_check);
      while(1)
      {
         system "stty -echo";
         $admin_password = prompt_default("Admin Password", "");
         print "\n";
         $admin_password_check = prompt_default("Admin Password (verify)", "");
         print "\n";
         system "stty echo";
         if($admin_password ne $admin_password_check)
         {
            print "Passwords did not match. Try again\n";
         }
         else { last };
      }
      push(@INC, "$wkn_cgi_dir");
      require "auth_lib.pl";
      if(! auth::write_user_info($admin_user,
         { "PassKey"=>auth::pcrypt1($admin_password),
         "AuthPath"=>'',
         "Permissions"=>'s',
         "Name"=>"Admin"}))
      {
         print "Error creating admin.\n";
      }
   }

#print "Try this link:\nhttp://localhost$cgi_root_wpath/wkn/browse.cgi\n";

sub parse_httpd
{
   my($line, $web_doc_root, $script_root, $script_alias, $user, $user_dir, $conf);

   for $conf ( "/etc/httpd/conf/httpd.conf", "/etc/httpd/conf/srm.conf" )
   {
      next unless(open( HCONF, $conf));
      while(defined($line = <HCONF>))
      {
         if($line =~ m:^DocumentRoot\s+:)
         {
            ($web_doc_root) = split_args($');
         }
         if($line =~ m:^ScriptAlias\s+: && ! defined($script_alias))
         {
            ($script_alias, $script_root) = split_args($');
         }
         if($line =~ m:^User\s+:)
         {
            ($user) = split_args($');
         }
         if($line =~ m:^UserDir\s+:)
         {
            ($user_dir) = split_args($');
         }
      }
      close(HCONF);
   }
   if(!defined($web_doc_root))
   {
      print "Warning: http configuration not found\n";
   }
   return ($web_doc_root, $script_root, $script_alias, $user, $user_dir);
}


sub split_args
{
   my($line) = @_;
   my(@args) = ();
   while($line =~ m:^\s*\"([^\"]*)\"|([^\"\s]+):)
#   while($line =~ m:^\s*\"([^\"]*)\"|([^\"\s]+)\s*:)
   {
      push(@args, $1) if(defined($1));
      push(@args, $2) if(defined($2));
      $line = $';
   }
   return (@args);
}

sub chomp_slashs
{
   my(@paths);
   foreach(@_)
   {
      $_ =~ s:/+$::;
      push( @paths, $_);
   }
   return(@paths);
}

sub prompt_default
{
   my($prompt, $default, $choices) = @_;
   my($line);

   do
   {
   if( length($prompt) + length($choices) + length($default) + 4 > 80)
   {
      print "$prompt $choices -\n  [$default]: ";
   }
   else
   {
      print "$prompt $choices [$default]: ";
   }
   $line = <STDIN>;
   chomp($line);
   $line = $default if($line eq "");
   } while(defined($choices) and ! ($line =~ m:^${choices}$:));

   return $line;
}

sub type_prompt
{
   my($type, $prompt, $default) = @_;

   if($type eq "BOOL")
   {
      return ('y' eq prompt_default($prompt, $default ? 'y': 'n', '(y|n)'))?1:0;
   }
   else
   {
      return prompt_default($prompt, $default);
   }
}

sub eval_var
{
   my($var) = @_;
   if(defined(${"${package}::define::$var"}))
   {  return ${"${package}::define::$var"} }
   elsif(defined(${"$var"}))
   { return ${"$var"} }
   else { return ();}
}

sub mkpath
{
   my($path, $mode) = @_;
   my(@paths) = split(/\/+/, $path);
   $path = '';
   if(@paths and $paths[0] eq '')
   {
     $path = '/';
     shift(@paths);
   }
   for my $dir (@paths)
   {
      $path .= $dir;
      return 0 unless ( -d $path or mkdir($path, $mode));
      $path .= '/';
   }
   return 1;
}
